Read file: ApiSentinel/client/src/lib/queryClient.ts

Read file: ApiSentinel/package.json

Here’s a tight, Replit-ready plan to get GitHub integration fully working and eliminate the “/github/undefined” + empty installations issues.

### 1) Clean up the UI flow (use the new GitHub App flow only)
- Replace the legacy GitHub page link with the Integrations page.
- Edit `client/src/components/navigation.tsx`:
```diff
- { path: "/github/connect", label: "GitHub", icon: Github },
+ { path: "/integrations", label: "GitHub", icon: Github },
```
- Optional: delete `client/src/pages/github-connect.tsx` to avoid future regressions.

Why: The legacy page expects `/api/auth/github` to return `authURL` and redirects to `/github/undefined`. The Integrations page already uses the GitHub App flow.

### 2) Fix backend-user linkage and table mismatches
Right now you write installations to `github_app_installations` (via `storage.saveUserGitHubInstallation`) but read from another table (`github_installations`) and (worse) use a `default-user` fallback. Result: empty arrays in your logs.

Implement these simple backend edits:

- Add a list + delete for the correct table in `storage`:
```startLine:720:endLine:738:server/storage.ts
  async getUserGitHubInstallation(userId: string): Promise<GitHubAppInstallation | undefined> {
    const [installation] = await db
      .select()
      .from(github_app_installations)
      .where(eq(github_app_installations.user_id, userId));
    return installation || undefined;
  }
+ async getUserGitHubInstallations(userId: string): Promise<GitHubAppInstallation[]> {
+   return await db
+     .select()
+     .from(github_app_installations)
+     .where(eq(github_app_installations.user_id, userId));
+ }
+ async deleteUserGitHubInstallation(userId: string, installationId: number): Promise<void> {
+   await db
+     .delete(github_app_installations)
+     .where(and(
+       eq(github_app_installations.user_id, userId),
+       eq(github_app_installations.installation_id, installationId)
+     ));
+ }
```

- Use auth and these storage methods in `server/routes.ts`:
```startLine:180:endLine:236:server/routes.ts
  // GitHub App installation routes
  app.get("/api/auth/github/install", authMiddleware, async (req: any, res) => {
    try {
      const { githubAppService } = await import("./services/github-app");
      const installUrl = githubAppService.getInstallationURL(req.user.id);
      res.json({ installUrl });
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/auth/github", authMiddleware, async (req: any, res) => {
    try {
      const { githubAppService } = await import("./services/github-app");
      const installationId = await githubAppService.getUserInstallationId(req.user.id);
      res.json({ connected: !!installationId, hasInstallation: !!installationId });
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });

  app.get("/api/auth/github/repositories", authMiddleware, async (req: any, res) => {
    try {
      const { githubAppService } = await import("./services/github-app");
      const installationId = await githubAppService.getUserInstallationId(req.user.id);
      if (!installationId) return res.status(400).json({ error: "GitHub App not installed" });
      const repos = await githubAppService.getInstallationRepositories(installationId);
      res.json(repos);
    } catch (error: any) {
      res.status(400).json({ error: error.message });
    }
  });
```

- Replace the three “installations” endpoints to use auth + the right table:
```startLine:786:endLine:809:server/routes.ts
- app.get("/api/github/installations", async (req, res) => {
-   const userId = req.query.userId as string || 'default-user';
-   const installations = await githubService.getUserInstallations(userId);
-   res.json(installations);
- });
+ app.get("/api/github/installations", authMiddleware, async (req: any, res) => {
+   const installations = await storage.getUserGitHubInstallations(req.user.id);
+   res.json(installations);
+ });

- app.delete("/api/github/installation/:id", async (req, res) => {
-   const userId = req.query.userId as string || 'default-user';
-   const installationId = parseInt(req.params.id);
-   await githubService.removeInstallation(userId, installationId);
-   res.status(204).send();
- });
+ app.delete("/api/github/installation/:id", authMiddleware, async (req: any, res) => {
+   const installationId = parseInt(req.params.id);
+   await storage.deleteUserGitHubInstallation(req.user.id, installationId);
+   res.status(204).send();
+ });

- app.get("/api/github/installation/:id/repositories", async (req, res) => {
+ app.get("/api/github/installation/:id/repositories", authMiddleware, async (req, res) => {
   const installationId = parseInt(req.params.id);
   const repositories = await githubService.getInstallationRepositories(installationId);
   res.json(repositories);
 });
```

- Update the client to stop sending a fake `userId` (auth now used):
```startLine:112:endLine:121:client/src/pages/integrations.tsx
- const response = await fetch(`/api/github/installation/${installationId}?userId=default-user`, {
+ const response = await fetch(`/api/github/installation/${installationId}`, {
    method: 'DELETE',
    headers: { 'Authorization': `Bearer ${localStorage.getItem('auth-token')}` },
  });
```

### 3) Ensure Replit environment variables (Secrets)
Add these in Replit “Secrets”:

- DATABASE_URL: your Neon/PG URL
- TOKEN_ENCRYPTION_KEY: 32 random bytes hex (e.g., run in shell: `node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"`)
- GITHUB_APP_ID: your GitHub App ID
- GITHUB_PRIVATE_KEY: paste the entire PEM content exactly, preserving newlines (the code uses `.replace(/\\n/g, '\n')`)
- GITHUB_OAUTH_CLIENT_ID / GITHUB_OAUTH_CLIENT_SECRET: required by `validateEnv()` (even if you primarily use the App flow)
- Optional: GITHUB_WEBHOOK_SECRET (if you connect webhooks)

No need to set `REPLIT_DOMAINS`; Replit provides it at runtime and `github-app.ts` already reads it to craft the `setup_url`.

### 4) Configure the GitHub App
- Permissions:
  - Repository permissions: Contents (Read), Metadata (Read)
- Webhook URL (optional for now): `https://<your-replit-domain>/api/github/webhook`
  - If used, set the secret in both GitHub and Replit.
- Install URL: backend constructs `https://github.com/apps/the-api-sentinel/installations/new?setup_url=...` including a `state` tying back to the user for auto-linking.
- Setup callback: We pass `setup_url` to `/api/auth/github/setup` which auto-links and then redirects to `/integrations`.

### 5) Database schema
- Push tables: in Replit shell run:
  - `npm run db:push`
- Confirm tables include `github_app_installations` (the one we are using).

### 6) Run and verify on Replit
- Restart the repl: `npm run dev`
- In the app:
  - Login → Integrations → “Connect GitHub Account”
  - You should be redirected to GitHub App install
  - After install, you’ll land back at `/integrations` with your installation listed.
  - Click an installation → repositories should load.
  - Test delete installation from the UI to verify the new DELETE route.

### 7) Optional hardening
- Protect `/api/github/webhook` by validating `x-hub-signature-256` (you already have patterns for Slack; same approach).
- If you plan to keep OAuth, fix the frontend callback to hit the API route:
  - In `GitHubCallbackHandler`, change the redirect to `/api/auth/github/callback${window.location.search}`.
  - Ensure `server/routes.ts` has the `/api/auth/github/callback` route (present in your generated build).

Status: I analyzed the repo, identified the two root causes (legacy page redirecting to `/github/undefined`, and backend reading installations from the wrong table with a `default-user` fallback), and laid out exact edits and Replit setup steps to make the GitHub App path work end-to-end.

- Changed nav to point to `"/integrations"`.
- Switched the installations endpoints to use `authMiddleware` and the `github_app_installations` table via `storage`.
- Removed fake `userId` query usage on the client.
- Listed precise Replit Secrets, GitHub App settings, and DB push command.